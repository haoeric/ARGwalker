package IRiSapp;
use strict;
require Exporter;

# parse the output data of IRiS for individual recombination history estimation, with optimization of the graph mining algorithm
# Chen Hao, 10 Oct 2013

our @ISA = qw(Exporter);
our @EXPORT_OK = qw(iris1 iris2);


sub new {
    my $self = {};
     
    $self->{NODE_INFO} = [];         # store all node info, an array of node name, index start from 0, "id - name"
    $self->{LEAF_NODE} = {};         # store the leaf node index, note that a leaf node could be also recom_node or mutation_node, "id -> name"
    $self->{ROOT_NODE} = {};         # store the root node index with node name, "id -> name"
    $self->{RECOM_NODE} = {};        # store the recombination node index with node name, "id -> name"
    $self->{MUTATION_NODE} = {};     # store the mutation node index with node name, "id -> name"
    $self->{NODE_AGE} = [];          # an array storing the age of each node, index start from 0, "id - age"
    
    $self->{CAUSAL_SNP} = {};        # a hash to store the causal SNP type of each individual, "individual_name -> causal_SNP_type"  
    $self->{TRUST_RECOM_NODE} = [];  # store the recombination node index after filtering potential bias recombination nodes
    $self->{FOR_ARG_MATRIX} = [];    # forward transition matrix translated from the subARG generated by IRiS
    $self->{FOR_NB_VECTOR} = [];     # a vector storing the number of neighbour nodes of each node by forward walking
    $self->{FOR_AE_VECTOR} = [];     # a vector storing the number of all connected edges of each node by forward walking
    $self->{FOR_P_MATRIX} = [];      # the forward probability matrix
    $self->{BAC_ARG_MATRIX} = [];    # backward transition matrix translated from the subARG generated by IRiS
    $self->{BAC_NB_VECTOR} = [];     # a vector storing the number of neighbour nodes of each node by backward walking
    $self->{BAC_AE_VECTOR} = [];     # a vector storing the number of all connected edges of each node by bacward walking
    $self->{BAC_P_MATRIX} = [];      # the backward probability matrix
    
    $self->{IO_MATRIX} = {};         # hash matrix showing the off-springs of each root nodes
    $self->{IRV_VECTOR} = [];        # estimated recombination volume of each lead node   
    $self->{IRR_VECTOR} = {};        # estimated recombination rate of each individual, "individual_name -> recom_rate"
      
    bless($self);    
    return $self;
}


#################################
# run IRiS to get the net file
#################################
sub run_iris{
	my ($self, $filetitle) = @_;
	# run iris1 then iris2
	system ("iris1 $filetitle");
		
	eval {system ("iris2 $filetitle") };	
	print "skip $filetitle, with error $@ \n" if $@; 
}
	
	
#####################################
# Data reading and initialization
#####################################

# read info from the _.net file generated by IRiS2, and get the {FOR_ARG_MATRIX} & {BAC_ARG_MATRIX}, then mark the nodes 
sub read_net_data {
	my ($self, $netfile) = @_;
	
	open NET, $netfile or die "can't open netfile: $!";
	
	# store the ARG nodes info into {NODE_INFO}
	my $ln = <NET>;
	while ($ln = <NET>){
		chomp $ln;
		last if ($ln =~ /^\*/);	
		if ($ln =~ /^\w+\s\"/){
			my @verticesinfo = split (/\s/, $ln);
			substr($verticesinfo[1], 0, 1) = "";  # remove the starting quotation mark
			chop $verticesinfo[1];                # remove the ending quotation mark
			#	leaf node has only outgoing edges, also here start with "Seq" or "NEW", different markers for different sample
			if ($ln =~ /^\w+\s\"\D/){             # here note different label *** NOTE FOR CHANGE***
				$self->{LEAF_NODE}->{$verticesinfo[0]-1} = $verticesinfo[1];}
					
			push(@{$self->{NODE_INFO}}, $verticesinfo[1]);  #note here the node index start from 0	
		}
	}
	
	# initialize the {BAC_ARG_MATRIX}
		$self->init_matrix(scalar @{$self->{NODE_INFO}}, scalar @{$self->{NODE_INFO}}, $self->{FOR_ARG_MATRIX});

	# store the ARG edges info into {BAC_ARG_MATRIX} and {FOR_ARG_MATRIX}
	while ($ln = <NET>){
		chomp $ln;
		next if ($ln =~ /^\*/); 
		if ($ln =~ /^\d+\s\d+/){
			my @arcsinfo = split (/\s/, $ln);	
			$self->{FOR_ARG_MATRIX}->[$arcsinfo[0]-1][$arcsinfo[1]-1] += $arcsinfo[2];
		}	
	}	
		close NET;
		
	# get the {FOR_ARG_MATRIX} by transpose the {BAC_ARG_MATRIX}
	  $self->{BAC_ARG_MATRIX} = $self->mtr($self->{FOR_ARG_MATRIX});
		
	# mark the nodes 	
		$self->mark_node(scalar @{$self->{NODE_INFO}}, scalar @{$self->{NODE_INFO}});	
}

# mark the nodes of {BAC_ARG_MATRIX}, this function used by "read_net_data" 
sub mark_node{	
	my ($self, $row, $column) = @_;	
  print "can't mark the ARG matrix, it's empty!\n" if  ($row == 0 || $column == 0);
  
  for my $i (0 .. $row-1){
   my $incomingnum = 0;   # nodes that flow into $i
   my $outgoingnum = 0;   # nodes that outgoing from $i
  	for my $j (0 .. $column-1){
  	 $incomingnum += $self->{FOR_ARG_MATRIX}[$j]->[$i];
  	 $outgoingnum += $self->{FOR_ARG_MATRIX}[$i]->[$j];
  	}
  	  # root node has only outgoing edges
  		$self->{ROOT_NODE}->{$i} = $self->{NODE_INFO}[$i] if ($incomingnum == 0 && $outgoingnum > 0); 
  		# mutation node has only one incoming edges
  		$self->{MUTATION_NODE}->{$i} = $self->{NODE_INFO}[$i] if ($incomingnum == 1 && $outgoingnum > 0); 
  		# recombination node has more than 2 incoming edges
  		$self->{RECOM_NODE}->{$i} = $self->{NODE_INFO}[$i] if ($incomingnum >= 2 && $outgoingnum > 0) ; 	 #*** note that the recom node is unique if adding constriant && $outgoingnum > 0
  }
} 
	

# get the age of each node from the age file
sub read_age_data{
 my ($self, $agefile) = @_;
 open AGE, $agefile or die "can't open the age file!";
  while (my $ln = <AGE>){
    chomp $ln;
    my @ageinfo = split ("\t", $ln);
    push (@{$self->{NODE_AGE}}, $ageinfo[1]);
  }
 close AGE;
}


# read the tag file to get the causal SNP of each individual, $self->{CAUSAL_SNP}-> individual name = causal SNP type
sub read_tag_file{
	my ($self, $filetitle, $tagfile, $fileId) = @_;
	
	# get the position of the causal SNP of this file
	open TAG, $tagfile or die "can't open the tag file\n";
	my $tagline = <TAG>;  # skip head line
	my @allTags;
	while ($tagline = <TAG>){
		chomp $tagline;
		push (@allTags, $tagline);
  }
	close TAG;
	
  my $thisFileLine = $allTags[$fileId];
  my @thisTagInfo = split ("\t", $thisFileLine);
  die if $thisTagInfo[0] != $fileId;
  my $thisTagPosition = $thisTagInfo[1];   # the positon of this tag SNP  ####NOTE FOR CHANGE#####
  
  # get the causal SNP type of each individual
  my $hapfile = $filetitle.".txt";
  open HAP, $hapfile or die "can't open the hapfile!";
  while (my $ln = <HAP>){
	  chomp $ln;
	  if ($ln =~ /^\S/){      # start with non-whitespace
		  my @data = split (/\t/, $ln);
	    $self->{CAUSAL_SNP}->{$data[0]} = substr($data[1], $thisTagPosition, 1);    # individual name -> causal SNP type
	  }	
	}	
	close HAP;  
}


##################################################################
# mining the subARG graph with forward and backward direction
##################################################################

sub forward_walk{
 my ($self) = @_;
	
	my $row = scalar @{$self->{NODE_INFO}};
	my $column = $row;
 
	$self->init_matrix(1, $column, $self->{FOR_NB_VECTOR});
	$self->init_matrix(1, $column, $self->{FOR_AE_VECTOR});
	$self->init_matrix($row, $column, $self->{FOR_P_MATRIX});
	
	# get the {FOR_NB_VECTOR}
	for my $i (0 .. $row-1){
   my $outgoingnum = 0;
  	for my $j (0 .. $column-1){
  	 $outgoingnum += $self->{FOR_ARG_MATRIX}[$i]->[$j];}	
  	 $self->{FOR_NB_VECTOR}->[0][$i] = $outgoingnum;
   }
   
   # get the {FOR_AE_VECTOR}
   for my $i (0 .. $row-1){
    if ($self->{FOR_AE_VECTOR}->[0][$i] == 0){
         $self->{FOR_AE_VECTOR}->[0][$i] = $self->for_min_graph($i); }
   }
   
   # get the {FOR_P_MATRIX}
    for my $i (0 .. $row-1){
     my $row_weight = 0;
     
      for my $j (0 .. $column-1){
  		if ($self->{FOR_ARG_MATRIX}[$i]->[$j] > 0){
  		   $row_weight += $self->{FOR_ARG_MATRIX}[$i]->[$j] + $self->{FOR_AE_VECTOR}->[0][$j];}
    	}
    	
    	for my $j (0 .. $column-1){
    	if ($self->{FOR_ARG_MATRIX}[$i]->[$j] > 0){
  		  $self->{FOR_P_MATRIX}->[$i][$j] = ($self->{FOR_ARG_MATRIX}[$i]->[$j] + $self->{FOR_AE_VECTOR}->[0][$j]) / $row_weight;}
    	}
    }  
}

sub backward_walk{
 my ($self) = @_;
	
	my $row = scalar @{$self->{NODE_INFO}};
	my $column = $row;
 
	$self->init_matrix(1, $column, $self->{BAC_NB_VECTOR});
	$self->init_matrix(1, $column, $self->{BAC_AE_VECTOR});
	$self->init_matrix($row, $column, $self->{BAC_P_MATRIX});
	
	# get the {BAC_NB_VECTOR}
	for my $i (0 .. $row-1){
   my $outgoingnum = 0;
  	for my $j (0 .. $column-1){
  	 $outgoingnum += $self->{BAC_ARG_MATRIX}[$i]->[$j];}	
  	 $self->{BAC_NB_VECTOR}->[0][$i] = $outgoingnum;
   }
   
   # get the {BAC_AE_VECTOR}
   for (my $i = $row-1; $i >= 0; $i--){
    if ($self->{BAC_AE_VECTOR}->[0][$i] == 0){
         $self->{BAC_AE_VECTOR}->[0][$i] = $self->back_min_graph($i); }
   }
   
   # get the {BAC_P_MATRIX}
    for my $i (0 .. $row-1){
     my $row_weight = 0;
     
      for my $j (0 .. $column-1){
  		if ($self->{BAC_ARG_MATRIX}[$i]->[$j] > 0){
  		   $row_weight += $self->{BAC_ARG_MATRIX}[$i]->[$j] + $self->{BAC_AE_VECTOR}->[0][$j];}
    	}
    	
    	for my $j (0 .. $column-1){
    	if ($self->{BAC_ARG_MATRIX}[$i]->[$j] > 0){
  		  $self->{BAC_P_MATRIX}->[$i][$j] = ($self->{BAC_ARG_MATRIX}[$i]->[$j] + $self->{BAC_AE_VECTOR}->[0][$j]) / $row_weight;}
    	}
   }
}

# iteratively mining the graph for path weight count with forward and backward direction
sub for_min_graph{
	my ($self, $i) = @_;
	
	my $column = scalar @{$self->{NODE_INFO}};
	
		for my $j (0 .. $column-1){
			if ($self->{FOR_ARG_MATRIX}[$i]->[$j] > 0){
			
			   if ($self->{FOR_AE_VECTOR}->[0][$j] > 0){
            $self->{FOR_AE_VECTOR}->[0][$i] += $self->{FOR_ARG_MATRIX}[$i]->[$j] + $self->{FOR_AE_VECTOR}->[0][$j];}
            elsif($self->{FOR_NB_VECTOR}->[0][$j] == 0){
               $self->{FOR_AE_VECTOR}->[0][$i] += $self->{FOR_ARG_MATRIX}[$i]->[$j]; }
            else{
             $self->{FOR_AE_VECTOR}->[0][$i] += $self->{FOR_ARG_MATRIX}[$i]->[$j] + $self->for_min_graph($j); }		
			}
		}
		
		return ($self->{FOR_AE_VECTOR}->[0][$i]);		
	}
	
sub back_min_graph{
	my ($self, $i) = @_;
	
	my $column = scalar @{$self->{NODE_INFO}};
	
		for (my $j = $column-1; $j >= 0; $j--){
			if ($self->{BAC_ARG_MATRIX}[$i]->[$j] > 0){
			
			   if ($self->{BAC_AE_VECTOR}->[0][$j] > 0){
            $self->{BAC_AE_VECTOR}->[0][$i] += $self->{BAC_ARG_MATRIX}[$i]->[$j] + $self->{BAC_AE_VECTOR}->[0][$j];}
            elsif($self->{BAC_NB_VECTOR}->[0][$j] == 0){
               $self->{BAC_AE_VECTOR}->[0][$i] += $self->{BAC_ARG_MATRIX}[$i]->[$j]; }
            else{
             $self->{BAC_AE_VECTOR}->[0][$i] += $self->{BAC_ARG_MATRIX}[$i]->[$j] + $self->back_min_graph($j); }		
			}
		}
		
		return ($self->{BAC_AE_VECTOR}->[0][$i]);		
	}
	
	
###########################################################################
# recombination rate (recom_vol && indiv_recom) estimation by random walk
###########################################################################

		
# tracing the path of each root node
sub path_tracing{
	my ($self) = @_;
		
	my $column = scalar @{$self->{NODE_INFO}};

	foreach my $rootid (keys %{$self->{ROOT_NODE}}){ 
	  my $iv_vector = [];     # the initial volume vector of each root node
	  my $ir_vector = [];     # the distribution on each leaf node
	  $self->init_matrix(1, $column, $iv_vector);
	  $iv_vector->[0][$rootid] = 10;   # $self->{IRV_VECTOR}->[0][$rootid];
	 
	  my $alpha = 1;  # random walk parameter
	  $ir_vector = $self->random_walk($iv_vector, $self->{FOR_P_MATRIX}, $alpha);
	 
	  $self->{IO_MATRIX}->{$rootid} = $ir_vector;   # store the path of each leaf node
  } 
}

# filter potential bias recombination nodes in ERRiS ARG, {RECOM_NODE} to {TRUST_RECOM_NODE}
sub renew_age{
	my ($self) = @_;

	foreach my $rootid (keys %{$self->{ROOT_NODE}}){
	  my $offspringCount = 0;
		foreach my $leafid (keys %{$self->{LEAF_NODE}}){
		  $offspringCount++ if ($self->{IO_MATRIX}->{$rootid}->[0][$leafid] > 0);			    	  	    	
		}
		$self->{NODE_AGE}[$rootid] = $offspringCount * $self->{NODE_AGE}[$rootid];
	}	
}
	
# estimate the recombination volume of each leaf node using forward walk
sub recom_vol_estimation {
	my ($self) = @_;
  
  my $iv_vector = [];     # the initial volume vector, correponding to the renewed age of each root node
	my $column = scalar @{$self->{NODE_INFO}};
	$self->init_matrix(1, $column, $iv_vector);
	foreach	(sort {$a <=> $b} keys %{$self->{ROOT_NODE}}){
		$iv_vector->[0][$_] = $self->{NODE_AGE}[$_];
	}
	
	my $alpha = 1;  # random walk parameter
	$self->{IRV_VECTOR} = $self->random_walk($iv_vector, $self->{FOR_P_MATRIX} ,$alpha);
    
}	

# split the lead node to individual	
sub indiv_recom_estimation{
	my ($self) = @_;
	
	foreach my $leafid (sort {$a <=> $b} keys %{$self->{LEAF_NODE}}){ 
		my $thisLeafRate = $self->{IRV_VECTOR}->[0][$leafid];
	  my @leafMembers = split ("\,", $self->{LEAF_NODE}->{$leafid});
	  foreach (@leafMembers) {
	    $self->{IRR_VECTOR}->{$_} = $thisLeafRate; 	 # individula name  points to the corresponding reconbination rate
	  }
  }  
}
	
		
# random walk model
sub random_walk{
	my ($self, $m1, $m2, $alpha) = @_;
	my $result = $m1;
	my $m3 = [];
	
	do{		
		# algorithm: m3 = a(m1 * m2) + (1-a)m1
		$m3 = $self->madd( $self->nmmult($alpha, $self->mmult($m1, $m2)), $self->nmmult(1 - $alpha, $m1) ); 
		$result = $self->madd($result, $m3);
		$m1 = $m3;
		} while($self->mnormal($m1) > 0);  
		
		return ($result); 
  }


#######################################################################
# print the output data, indi_name recom_rate avg_rate simu_allel
######################################################################


sub write_data{
  my($self,$outfile) = @_;
     
  #get the average recombination rate 
  my $totalNum = 0;
  my $totalRate = 0;
  my $avgRate = 0; 
  foreach (values %{$self->{IRR_VECTOR}}){
    $totalNum++;
    $totalRate += $_;
  }
	$avgRate = $totalRate / $totalNum;
	
  # print results only with average rate bigger than 2.0, to filter all cold samples
  if ($avgRate > 2.0){
    # print the rate, average rate, and the transformed pseudo SNP type 
    open (OUT, ">>$outfile") or die "can't open the output file!";
    print OUT "indi_name\trecom_rate\tavg_rate\tsimu_allele\n";      # head line
  
    for(my $i = 0; $i < 180; $i++){
  	  my $thisRate = 0;	  
	  my $indi_name = "Seq".$i;     #*** note that this hap contains 180 samples and with name tag "Seq", NOTE FOR CHANGE***
	  print OUT $indi_name,"\t";
      $thisRate = $self->{IRR_VECTOR}->{$indi_name} if ($self->{IRR_VECTOR}->{$indi_name});
      print OUT $thisRate,"\t",$avgRate,"\t";
      print OUT "1\n" if $thisRate >= $avgRate;
      print OUT "0\n" if $thisRate < $avgRate;   		    
	}	  
    close OUT;
  }
	  	  
}


#########################################
# matrix operation functions
#########################################

# initialize a matrix with value of 0 
sub init_matrix{
	my ($self, $row, $column, $namepoint) = @_;
	for my $i (0 .. $row-1){
		for my $j (0 .. $column-1){
		$namepoint->[$i][$j] = 0;
			}
		}
	}
	
# matrix transpose function
sub mtr{
	my ($self, $m1) = @_;
	my ($m1rows,$m1cols) = $self->matdim($m1);
        
    my $result = [];
    my ($i, $j);

    for $i (0 .. $m1rows-1) {
      for $j (0 .. $m1cols-1) {   	
      $result->[$j][$i] = $m1->[$i][$j];}
      	}   
	 return $result;
	}

# matrix addition function
sub madd{
	my ($self, $m1, $m2) = @_;
	my ($m1rows,$m1cols) = $self->matdim($m1);
  my ($m2rows,$m2cols) = $self->matdim($m2);
  
   unless ($m1rows == $m2rows && $m1cols == $m2cols) {  # raise exception
        die "IndexError: matrices size don't match: $m1rows != $m2rows or $m1cols != $m2cols";}
        
    my $result = [];
    my ($i, $j);

    for $i (0 .. $m1rows-1) {
      for $j (0 .. $m1cols-1) {   	
      $result->[$i][$j] = $m1->[$i][$j] + $m2->[$i][$j];}
      	}   
	 return $result;	
	} 
		
# Frobenius norm of a matrix function
sub mnormal{
	my ($self, $matrix) = @_;
	my ($mrows,$mcols) = $self->matdim($matrix);
	my $result = 0;
  my ($i, $j);
   for $i (0 .. $mrows-1) {
      for $j (0 .. $mcols-1) {	
      	$result += $matrix->[$i][$j] ** 2;
      	}
      	}   
	return sqrt($result);
	}	
	
# a number multiple a matrix function
sub nmmult{
	my ($self, $number, $matrix) = @_;
	my ($mrows,$mcols) = $self->matdim($matrix);
  
    my $result = [];
    my ($i, $j);
    for $i (0 .. $mrows-1) {
      for $j (0 .. $mcols-1) {	
      	$result->[$i][$j] = $matrix->[$i][$j] * $number;
      	}
      	}   
	 return $result;
	}
		
# matrix multiplication function	
sub mmult {
    my ($self, $m1, $m2) = @_;
    my ($m1rows,$m1cols) = $self->matdim($m1);
    my ($m2rows,$m2cols) = $self->matdim($m2);

    unless ($m1cols == $m2rows) {  # raise exception
        die "IndexError: matrices don't match: $m1cols != $m2rows";
    }

    my $result = [];
    my ($i, $j, $k);

    for $i (0 .. $m1rows-1) {
        for $j (0 .. $m2cols-1) {
            for $k (0 .. $m1cols-1) {
                $result->[$i][$j] += $m1->[$i][$k] * $m2->[$k][$j];
            }
        }
    }
    return $result;
}

# print a matrix with tab
sub printm{
	my ($self, $matrix, $outfile) = @_;
	my ($mrows,$mcols) = $self->matdim($matrix);
  my ($i, $j);
  open (OF, ">>$outfile") or die "$! can't open the out put file!";
   for $i (0 .. $mrows-1) {
      for $j (0 .. $mcols-1) {	
      	printf OF "%.6f\t",$matrix->[$i][$j];
      	}
      	print OF "\n";
      	} 
      	print OF "\n\n";
      	close OF;
	}

# check the dimension of a matrix, rows and columns
sub matdim {
    my ($self, $matrix) = @_;
    my $rows = $self->veclen($matrix);
    my $cols = $self->veclen($matrix->[0]);
    return ($rows, $cols);
  }

sub veclen {
    my ($self,$ary_ref) = @_;
    my $type = ref $ary_ref;
    if ($type ne "ARRAY") { die "$type is bad array ref for $ary_ref" }
    return scalar(@$ary_ref);
  }



1;